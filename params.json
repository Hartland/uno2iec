{"name":"Uno2iec","tagline":"A commodore (CBM) 1541 emulator on the Arduino Uno, using any desktop PC (or raspberry PI with raspbian) as a media host.","body":"# UNO2IEC README\r\n\r\n\r\n**DISCLAIMER:**\r\n_The author is in no way responsible for any problems or damage caused by_\r\n_using this code. Use at your own risk._\r\n\r\n**LICENSE:**\r\n_This code is distributed under the GNU Public License_\r\n_which can be found at http://www.gnu.org/licenses/gpl.txt_\r\n\r\n\r\n\r\n================================================================================\r\n\r\nDescription\r\n------------\r\nThe UNO2IEC device simulates a 1541 drive and enables loading and saving files or\r\nprograms between a CBM and any \"current\" folder on the host system. The host system location can be a network share,\r\nan USB or SD flash media, SSD or any hard disk that is supported by a Windows, Linux or Mac operating systems.\r\n\r\nThe direct commununication with the CBM is an Arduino (uno, nano, dumilanouve or similar) communicating over a regular serial line\r\nwith the media host system. The serial line can be either the gpio pin mapped serial port on the arduino or the\r\nserial over USB port. In case using the USB-over-serial port, the benefit is automatic reset of the Arduino when the\r\nhost connects to it.\r\n\r\nNote: As of writing the project does not yet support any turboloaders. There are however plans and ideas to provide\r\nthis support. It should be possible with some extra work of performance tuning for the optimum handling of the\r\nserial interface between the arduino and the host. The memory and Arduino computing performance is more than good enough.\r\n\r\nThe project inherits both code and ideas from the MMC2IEC project, originally written by\r\nJan Derogee's and Lars Pontoppidan. The sd2iec project is also used as a reference for the IEC interface and commodore\r\ndos protocols. Their original work and achievements is great and highly respected.\r\n\r\nThe code in this project however, has been subject to heavy redesign. While much of it was being ported to C++ and Qt,\r\nthe main idea is to let the old commodore targeted media be transferred from a PC host rather than just a MMC or SD card.\r\n\r\nThe design of this project required the IEC protocol between the CBM and the emulated 1541 to be refactored into having\r\ndivided responsibilities between the Arduino (as a low level middlehand) and the PC host as a media-tank.\r\nA secondary proprietary RS232-serial based protocol between the Arduino is utilized to be able to transfer the actual media to\r\nthe CBM. This protocol was designed for compactness and performance in order to maintain the IEC transfer speed.\r\n\r\n\r\n# Target device\r\nAtmel ATMega328 (Arduino Uno) at ~16 MHz, 32KB flash, 2 KB SRAM, 1KB EEPROM.\r\n\r\n\r\nContact\r\n-------\r\nThis project was created by:\r\n\t\tLars Wadefalk, email: lars@wadefalk.se\r\n\r\nProject homepage:\r\n\t\thttp://TODO.com\r\n\r\n\r\nHardware setup and variations\r\n-----------------------------\r\nArduino Uno/Nano: ATmega 16U2 328 microcontroller @ 16Mhz, 32KB flash, SRAM 2KB, EEPOM 1 KB.\r\nConnect at least ATN, CLOCK, DATA and GND pin to the IEC bus on the CBM. The RESET and SRQIN (latter one is unused on the C64)\r\nare optional to wire, however if you don't connect the RESET pin, the HAS_RESET_LINE definition should be commented out in the\r\nfile global_defines.h. The SRQ_IN pin may be later supported for C128 compatability.\r\n\r\nThe Arduino UNO can be bought very cheap at dx.com:\r\nhttp://dx.com/p/uno-r3-development-board-microcontroller-mega328p-atmega16u2-compat-for-arduino-blue-black-215600\r\nSame goes for the Arduino NANO which is even more compact and cheap:\r\nhttp://dx.com/p/nano-v3-0-avr-atmega328-p-20au-module-board-usb-cable-for-arduino-118037\r\n\r\nOptional: LED matrix with MAX7219 controller.\r\nCan be bought cheap at dx.com with 5 dupont lines:\r\nhttp://dx.com/p/max7219-dot-matrix-module-w-5-dupont-lines-184854\r\nWhether or not using the LED matrix when compiling, either define or comment out the USE_LED_DISPLAY macro in the\r\nglobal_defines.h header in the uno2iec project.\r\nOptional: HC-06 compatible Bluetooth module. This will provide the possibility to make your arduino completely wirelessly\r\ncommunicating with the PC media host. The JY-MCU is cheap, around 8 bucks and is pretty easy to configure:\r\nhttp://dx.com/p/jy-mcu-arduino-bluetooth-wireless-serial-port-module-104299\r\nSee separate section further down.\r\n\r\nCables:\r\n-------\r\nYou can use the following jumper wires bought cheaply at dx.com if you're using a UNO:\r\nhttp://dx.com/p/breadboard-jumper-cable-wires-for-electronic-diy-65-cable-pack-121345\r\nIf you have an Arduino Mini needs female cables instead, use the following:\r\nhttp://dx.com/p/single-port-female-to-female-jumper-wire-set-50-pack-20cm-length-55454\r\n\r\nEither connect Arduino to a PC, MAC. Media host side project can be compiled on either Linux, Windows or Mac desktop.\r\nIt works on the Raspberry Pi as a host as well. Connect two serial pins (RX, TX, twisted of course) on the PI to the arduino. A third\r\npin may also be connected with the purpose to reset the Arduino from the PI side (the PI uses the wiringPi project for GPIO access). The\r\nraspbian image is the suggested linux to use on Pi, it needs Qt build and runtime support.\r\nFor more info about how to prepare a raspberry pi properly for external serial communication, read the notes.txt file.\r\nThere are a few details when it comes to releasing the serial port from the kernel log.\r\n\r\n\r\nHow to build\r\n------------\r\nOpen the PC/Raspberry project (.pro) file in Qt creator and build either as release or debug.\r\nFor windows, move back to the projects page and untick the \"Shadow build\" option. This puts object and executable\r\nfiles in release and debug folders under the source folder.\r\n\r\n\r\nREQUIRES: (external dependencies):\r\nQextSerialPort project:\r\nhttps://code.google.com/p/qextserialport/\r\n\r\nThe QextSerialPort project should be located on the same directory level as the \"rpi2iec\" project.\r\n\r\nOptional: Max7219 driver library (modified by Lars Wadefalk to c++ with support for progress bar display and scroller).\r\nGithub project:\r\nhttps://github.com/Larswad/arduino_max7219.git\r\nTo make use of the display features, enable the global define USE_LED_DISPLAY in the global_defines.h header.\r\n\r\nFirst build the Qt project on the desired platform. Then build and deploy the arduino project using the latest arduino\r\nsuite to the arduino target.\r\n\r\n\r\nFiles in release:\r\n-----------------\r\nREADME.TXT (this file)\r\nnotes.txt\r\nTODO: changes.txt\r\nTODO: license.txt\r\n\r\n./\t\tUnder repo root is the PC/Raspberry Qt project files.\r\nuni2iec/\tAll files under here is the arduino sketch.\r\n\r\nThe logging\r\n-----------\r\nEach line in the logging box gives information on what is going on between the host, the arduino and the CBM.\r\nEach line has a date and time attached to the event. The event itself can take four different states:\r\n\r\nS: Success, something went good.\r\nI: Information, something happens, just providing the info\r\nW: Warning, Something happened, might not be a problem\r\nE: Error, Something went sideways.\r\n\r\nThe next field is a facility, it provides information about the part of the code that is giving the information.\r\nIf the facility contains an \"R:\" in front of it, it is the remote that has relayed the message to the host, the\r\nfacility in that case is one at the remote party.\r\nThe last field is the message part, informing about what has happened.\r\n\r\n\r\nWhat else?\r\n----------\r\nIdeas and improvements are highly welcome. Please contribute to this project!\r\nThe retro machine community gains from it.\r\n\r\nThere are a few coding guidelines I would like to be followed (except for the ones who are obvious by just looking\r\nat the present code).\r\n\r\nThe c++ files should have cpp and hpp file extensions (arduino environment however seems to prefer .h extensions for headers,\r\nso let's honor that).\r\nTABs instead of spaces are used (!), personally I use 2 indents (blanks) for each TAB, but use your own flavor.\r\nUsing TABs gives us more freedom.\r\n\r\nThere is NO limitation to 80 columns at all (or even 40 :-) ), but use common sense.\r\nFor splitted lines, operators are placed at the beginning of each new line to make code more clear (Qt style).\r\n\r\nTry to use constants or enums rather than preprocessor defines, and try to keep methods/functions const, if possible or suitable.\r\nPrefer passing variables by reference, when possible.\r\n\r\nUse camelCase!\r\n\r\nBlanks: Use them between operators, NOT before or after any parenthesis.\r\nOpening curly braces on same line for: while, do, for, if, namespace keywords. Not for classes, structs and typedefs.\r\nTwo linefeeds between each method or function, make it clear when a new function starts.\r\nUse common sense for other linefeeds.\r\n\r\n\r\nUse textual operators instead of the (sadly enough) commonly used operators, the textual ones make things clearer and less error prone:\r\nnot_eq instead of !=\r\nnot instead of !\r\nand instead of &&\r\nbitand instead of &\r\nand_eq instead of &=\r\nor instead of ||\r\nbitor instead of |\r\nor_eq instead of |=\r\nxor instead of ^\r\nand compl instead of ~\r\n\r\n\r\n\r\nSingle line if / while / for statements are allowed, like:\r\nif(isThisTrue)\r\n\tyesItWas+++;\r\n\r\nUse with care of course, if you have a macro or a more complex expression...think first.\r\n\r\nThink of minimal scope for variable declaration.\r\n\r\nTry to put related code/functions/method next to each other, like sections in a module. Don't mix unrelated code.\r\n\r\nPrefer Qt classes over STL, because STL is good but Qt is better.\r\n\r\nCommenting: Please do as much as you can. Comment WHY something is done, not preferably WHAT unless it is sort of\r\nobscure. Do not comment the obvious.\r\nIt is nice to add a single line comment at closing brace after end of long scope to indicate what scope it is, like:\r\n} // myFunction\r\nThis is to make code browsing easier.\r\n\r\n\r\nAlways Think about the DRY principle whenever writing code.\r\nYou are welcome to use templates but use them with care, if you find a need comment what is going on.\r\n\r\nPatterns...well use them to power the code, but remember this is not an art contest. Keep Things Simple.\r\n\r\nThink about your target platform when you code. Ardunio has little stack and memory, think optimization like in the old days.\r\nDesktop has lot of memory and computing power; but do think a little about efficient code anyway, it never hurts.\r\n\r\nIf there are any questions or advice to change these recommended guidelines, please don't hesitate to contact me.\r\nI am always open for change.\r\n\r\nDon't hesitate to let me know if I break my own recommendations...or better up, correct it.\r\n\r\n\r\nConfiguring the bluetooth module HC-06 (\"JY-MCU\") :\r\n---------------------------------------------------\r\nThe blueooth module should be connected to the arduino RX/TX lines. Important here is that between the Arduino TX and the bluetooth\r\nmodule RX-pin there should be a levelshifter from 5V to 3.3V to protect it, since the bluetooth module is operating at 3.3V and is not 5V tolerant.\r\nThis is easily built using a couple of resistors, or a cheap simple to use four-way level shifter can be bought at dx.com as well.\r\nThe Arduino RX can go directly to the bluetooth module's TX line. The bluetooth module must be powered with 3.3V from the Arduino's 3.3 output pin.\r\nConnect a ground pin from the arduino to the bluetooth ground as well.\r\n\r\n1. Before actually connecting the module RX/TX lines to the arduino, the software (sketch) has to be prepared and flashed to the board\r\nin a special mode for a one-time software configuration of baudrate, PIN-code and device name.\r\nUncomment the CONFIG_HC06_BLUETOOTH define in the global_defines.h header (also set the baudrate definition in this header to the default one, 9600).\r\nCompile and upload the sketch to the arduino board. Note than you can NOT upload the sketch over USB while the RX/TX lines are connected\r\nto the bluetooth device! The USB-FTDI chip is disabled if the RX/TX lines are active on the board.\r\n\r\n2. After successful upload of the sketch (that is compiled for configuration), remove the USB connector and connect the RX/TX lines to the board.\r\nNow connect the USB to the arduino that now will perform the configuration of the device, this will go very quick, a matter of a few seconds.\r\nWhile doing this, do not have the bluetooth module connected wirelessly to any device because the device will only accept configuration data when not\r\nbeeing paired or connected wirelessly.\r\n\r\n3. Disconnect the USB cable again and remove the RX/TX lines again between arduino and bluetooth module.\r\nThen comment out the CONFIG_HC06_BLUETOOTH definition again so that the code will be back to running in normal mode.\r\nNow it is important to also restore the baudrate definition in the global_defines.h header to the acutal one that the module was\r\nconfigured to use when the device was configured. This parameter was set with an AT command in the main sketch file's setup function.\r\nThe baudrate in the main sketch file should have configured the device to 57600 (but that may of course be set to something else, if desired).\r\nConnect the USB to the Arduino, compile an upload the code again. The Arduino should now be in \"normal\" IEC emulation mode again.\r\n4. Remove the USB connector and connect the bluetooth module's RX/TX lines again. Now power up the device again with the USB connection.\r\n\r\n5. This should be enough to let the bluetooth module pair with the host PC and get the wireless communication working.\r\nWhen pairing, use the correct PIN code and then the generic drivers for a bluetooth COM-port device should be installed automatically.\r\nThis has been sucessfully tested on Windows 7 but should work with XP and Linux as well.\r\n\r\n6. You have to use the right COM-port when connecting the PC host application. When successfully connected, the module's red led stops flashing and\r\nis kept constantly lit as long as connection is established. If failing to connect the Qt host application, try once or twice again by\r\nclicking the \"Reset Arduino\" button in the UI. Do not forget to set the host application's baud rate in the settings dialog to the same\r\nbaud rate as the one that was configured for the bluetooth module.\r\n\r\n\r\nPowering the Arduino using the CBM TAPE-cassette port.\r\n------------------------------------------------------\r\nThe final step to get the Arduino IEC emulator completely wireless is to get rid of the need to power it from the PC USB connection.\r\nThe CBM's provides 5V power on the TAPE port. The current capability is well enough to power the Arduino and its peripherals.\r\nEither slaughter a cable connector from an existing datasette TAPE deck (perhaps old and broke) or buy one 6 pin female edge connector.\r\nThe 5V line should go to the Arduino board's VIN line. The ground line should also be connected to the Arduino's GND pin.\r\n\r\nThis should be enough to power the device when you switch on your commodore machine.\r\n\r\nBefore soldering the end of the TAPE connector's cable, it is highly recommended to measure the wires with a multimeter to make sure\r\nwhich one is the 5V and which is the ground. A simple mistake could ruin either the Arduino, or even worse your beloved vintage computer.\r\nUse shrinking tube to shield any exposed soldered wires to avoid accidental short circuits.\r\n\r\nAlternatively the arduino can be powered from either a battery pack or a cell-phone charger battery that carries a USB connection.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}